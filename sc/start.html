<!DOCTYPE html>
<html>
<head>
    <title>Private Chat</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; }
        #chat-box { height: 400px; border: 1px solid #ddd; padding: 10px; overflow-y: scroll; margin-bottom: 10px; background: #fafafa; }
        #message-input { width: 75%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; }
        #send-button { width: 23%; padding: 10px; background: #4CAF50; color: white; border: none; border-radius: 4px; }
        .message { margin: 10px 0; padding: 8px 12px; border-radius: 4px; }
        .your-message { background: #e3f2fd; margin-left: 20%; }
        .their-message { background: #f1f1f1; margin-right: 20%; }
        .typing { font-style: italic; color: #666; text-align: center; margin: 5px 0; }
        #status { padding: 8px; border-radius: 4px; margin-bottom: 10px; }
        .online { background: #e8f5e9; color: #2e7d32; }
        .offline { background: #ffebee; color: #c62828; }
    </style>
</head>
<body>
    <h1>Private Chat ðŸ’¬</h1>
    <div id="status" class="offline">ðŸ”´ Disconnected</div>
    <div id="chat-box"></div>
    <div id="typing-status"></div>
    <div style="display: flex; gap: 10px;">
        <input type="text" id="message-input" placeholder="Type your message..." disabled>
        <button id="send-button" disabled>Send</button>
    </div>

    <script>
        // CONFIG (Change these!)
        const REPO = "amirhjrad/amirhjrad.github.io";
        const CHAT_FILE = "chat-data.json";
        const SYNC_INTERVAL = 3000; // 3 seconds
        const MAX_RETRIES = 3;

        // Elements
        const chatBox = document.getElementById('chat-box');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const statusDiv = document.getElementById('status');
        const typingDiv = document.getElementById('typing-status');

        // State
        let githubToken = "";
        let messages = [];
        let lastUpdate = 0;
        let currentSHA = null;
        let isSaving = false;
        let retryCount = 0;
        let lastTypingTime = 0;

        // Initialize
        promptForToken();

        function promptForToken() {
            githubToken = prompt("Enter your GitHub token (with repo access):");
            if (!githubToken) {
                alert("Token required to chat!");
                return;
            }
            initializeChat();
        }

        async function initializeChat() {
            statusDiv.textContent = "ðŸŸ  Connecting...";
            statusDiv.className = "offline";
            
            try {
                await loadMessages();
                startSyncing();
                enableInput();
                statusDiv.textContent = "ðŸŸ¢ Connected!";
                statusDiv.className = "online";
            } catch (err) {
                statusDiv.textContent = `ðŸ”´ Error: ${err.message}`;
                console.error(err);
                setTimeout(promptForToken, 3000);
            }
        }

        async function loadMessages() {
            try {
                const url = `https://api.github.com/repos/${REPO}/contents/${CHAT_FILE}?t=${Date.now()}`;
                const res = await fetch(url, {
                    headers: { Authorization: `token ${githubToken}` }
                });

                if (!res.ok) {
                    if (res.status === 404) await createChatFile();
                    else throw new Error(res.status === 403 ? "Rate limited - wait a minute" : "Can't load chat");
                }

                const data = await res.json();
                const content = JSON.parse(atob(data.content));
                currentSHA = data.sha;

                if (content.lastUpdate > lastUpdate) {
                    lastUpdate = content.lastUpdate;
                    messages = content.messages;
                    renderMessages();
                    retryCount = 0;
                }
            } catch (err) {
                retryCount++;
                if (retryCount >= MAX_RETRIES) throw err;
                console.log(`Retrying... (${retryCount}/${MAX_RETRIES})`);
                await new Promise(r => setTimeout(r, 2000));
                return loadMessages();
            }
        }

        async function createChatFile() {
            const url = `https://api.github.com/repos/${REPO}/contents/${CHAT_FILE}`;
            const res = await fetch(url, {
                method: "PUT",
                headers: { Authorization: `token ${githubToken}` },
                body: JSON.stringify({
                    message: "Initial chat file",
                    content: btoa(JSON.stringify({
                        messages: [],
                        lastUpdate: 0
                    }))
                })
            });
            if (!res.ok) throw new Error("Failed to create chat file");
        }

        async function saveMessages(newMessages) {
            if (isSaving) return;
            isSaving = true;

            try {
                // Get latest SHA first
                const shaUrl = `https://api.github.com/repos/${REPO}/contents/${CHAT_FILE}`;
                const shaRes = await fetch(shaUrl, {
                    headers: { Authorization: `token ${githubToken}` }
                });
                if (!shaRes.ok) throw new Error("Can't get file version");
                currentSHA = (await shaRes.json()).sha;

                // Save with latest SHA
                const saveUrl = `https://api.github.com/repos/${REPO}/contents/${CHAT_FILE}`;
                const saveRes = await fetch(saveUrl, {
                    method: "PUT",
                    headers: { Authorization: `token ${githubToken}` },
                    body: JSON.stringify({
                        message: `Chat update ${new Date().toISOString()}`,
                        content: btoa(JSON.stringify({
                            messages: newMessages,
                            lastUpdate: Date.now()
                        })),
                        sha: currentSHA
                    })
                });

                if (!saveRes.ok) {
                    const err = await saveRes.json();
                    throw new Error(err.message || "Save failed");
                }

                messages = newMessages;
                lastUpdate = Date.now();
                renderMessages();
            } catch (err) {
                console.error("Save error:", err);
                throw err;
            } finally {
                isSaving = false;
            }
        }

        function startSyncing() {
            setInterval(async () => {
                try {
                    await loadMessages();
                    // Show typing indicator if partner recently typed
                    const partnerTyping = messages.find(m => 
                        m.sender === "typing" && 
                        Date.now() - new Date(m.time).getTime() < 5000
                    );
                    typingDiv.innerHTML = partnerTyping ? 
                        `<div class="typing">${partnerTyping.text}</div>` : "";
                } catch (err) {
                    console.log("Sync error:", err.message);
                }
            }, SYNC_INTERVAL);
        }

        function renderMessages() {
            chatBox.innerHTML = messages
                .filter(m => m.sender !== "typing")
                .map(msg => `
                    <div class="message ${msg.sender === "you" ? "your-message" : "their-message"}">
                        <strong>${msg.sender}:</strong> ${msg.text}
                        <div style="font-size:0.8em;color:#666">
                            ${new Date(msg.time).toLocaleTimeString()}
                        </div>
                    </div>
                `).join("");
            chatBox.scrollTop = chatBox.scrollHeight;
        }

        function enableInput() {
            messageInput.disabled = false;
            sendButton.disabled = false;
            messageInput.focus();

            messageInput.addEventListener('keyup', () => {
                lastTypingTime = Date.now();
            });

            // Send on Enter
            messageInput.addEventListener('keypress', async (e) => {
                if (e.key === "Enter") await sendMessage();
            });

            sendButton.addEventListener('click', sendMessage);
        }

        async function sendMessage() {
            const text = messageInput.value.trim();
            if (!text || isSaving) return;

            // Optimistically show message
            const tempId = Date.now();
            messages.push({
                id: tempId,
                sender: "you",
                text: text,
                time: new Date().toISOString()
            });
            renderMessages();

            // Disable input while saving
            messageInput.value = "";
            messageInput.disabled = true;
            sendButton.disabled = true;
            sendButton.textContent = "Sending...";

            try {
                await saveMessages(messages);
            } catch (err) {
                // Remove failed message
                messages = messages.filter(m => m.id !== tempId);
                renderMessages();
                messageInput.value = text;
                alert("Message failed. Try again.");
            } finally {
                messageInput.disabled = false;
                sendButton.disabled = false;
                sendButton.textContent = "Send";
                messageInput.focus();
            }
        }
    </script>
</body>
</html>